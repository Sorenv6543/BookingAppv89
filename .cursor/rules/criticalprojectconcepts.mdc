---
description: 
globs: 
alwaysApply: true
---
# Cursor Global Rules - Role-Based Property Cleaning Scheduler

> Read @project_summary.md and @tasks.md to understand **role-based multi-tenant architecture** and current task structure.
> Check @repomix-output.md for current project state and existing implementations.

## For each task:
1. **Context First**: Use Context7 tool to research relevant documentation from @context7_techstack_ids.md before starting
2. **Plan**: Use sequential thinking to break down the task and plan im*role-based considerations**
3. **Implement**: Build the feature following established **role-based patterns** from @project_summary.md
4. **Integrate**: Ensure implementation fits the **multi-tenant architecture** and Map collection patterns
5. **Test**: Create/update **role-specific tests** and use demo components for verification
6. **Update**: Change task status from "Not Started" to "Complete" in tasks.md
7. **Document**: Add detailed notes about implementation decisions, **role-specific features**, and any challenges
8. **Verify**: Check off task with [x] and ensure it enables future dependent tasks

---

## Key Patterns to Follow:

### **Role-Based Architecture Patterns**
- **Multi-Tenant Design**: Property owners (30-40 clients) vs cleaning business admin interfaces
- **Data Scoping**: Owner sees only their data, admin sees all data across all clients
- **Role-Specific Orchestrators**: HomeOwner.vue vs HomeAdmin.vue (not generic Home.vue)
- **Component Separation**: owner/, admin/, shared/ folder structure
- **Security Awareness**: Frontend filtering for UX, document need for backend RLS

### **Folder Structure Patterns**
```
components/
├── dumb/
│   ├── shared/          # Reusable across roles (PropertyCard, TurnAlerts)
│   ├── owner/           # Owner-specific UI (OwnerBookingForm, OwnerCalendarControls)
│   └── admin/           # Admin-specific UI (AdminBookingForm, CleanerAssignmentModal)
└── smart/
    ├── shared/          # Cross-role smart components (rare)
    ├── owner/           # Owner interface (HomeOwner, OwnerSidebar, OwnerCalendar)
    └── admin/           # Admin interface (HomeAdmin, AdminSidebar, AdminCalendar)

composables/
├── shared/              # Base business logic (useAuth, useValidation)
├── owner/               # Owner-scoped operations (useOwnerBookings, useOwnerProperties)
└── admin/               # Admin-scoped operations (useAdminBookings, useCleanerManagement)
```

### **Component Patterns**

#### **Dumb Components** (Pure UI)
- **Shared**: Same UI, different data per role
  ```vue
  <!-- Same component, different data scope -->
  <TurnAlerts :turns="ownerTurns" />    <!-- Owner: only their turns -->
  <TurnAlerts :turns="systemTurns" />   <!-- Admin: all system turns -->
  ```
- **Role-Specific**: Optimized for role needs
  ```vue
  <!-- Owner: Simple form -->
  <OwnerBookingForm :properties="myProperties" />
  <!-- Admin: Advanced form with cleaner assignment -->
  <AdminBookingForm :properties="allProperties" :cleaners="cleaners" />
  ```

#### **Smart Components** (Business Logic)
- **Role-Specific Orchestrators**: Each role has optimized interface
  ```typescript
  // HomeOwner.vue: Personal property management
  const { myProperties, myBookings, myTurns } = useOwnerDashboard();
  
  // HomeAdmin.vue: System-wide business management  
  const { allProperties, allBookings, systemTurns, cleaners } = useAdminDashboard();
  ```

#### **Component Communication** (Role-Aware)
```
Owner Flow:
OwnerSidebar → HomeOwner → OwnerCalendar
(Personal data, simple actions)

Admin Flow:
AdminSidebar → HomeAdmin → AdminCalendar
(System data, complex actions)
```

### **State Management Patterns**

#### **Shared Foundation** (No Changes)
- All stores use Map<string, T> collections
- Computed getters for filtering and derived state  
- Actions return entities for chaining
- Use reactive() for complex state, ref() for primitives

#### **Role-Based Data Access**
```typescript
// ✅ Owner-scoped composables
const useOwnerBookings = () => {
  const myBookings = computed(() => 
    Array.from(bookings.value.values())
      .filter(b => b.owner_id === currentUser.id)
  );
};

// ✅ Admin-scoped composables  
const useAdminBookings = () => {
  const allBookings = computed(() => 
    Array.from(bookings.value.values()) // No filtering
  );
};
```

### **Business Logic Patterns**

#### **Role-Specific Priority Calculation**
```typescript
// Owner: Personal turn alerts
export const getOwnerTurnAlerts = (userId: string, bookings: Map<string, Booking>) => {
  return Array.from(bookings.values())
    .filter(b => b.owner_id === userId && b.booking_type === 'turn');
};

// Admin: System-wide turn management
export const getSystemTurnAlerts = (bookings: Map<string, Booking>) => {
  return Array.from(bookings.values())
    .filter(b => b.booking_type === 'turn'); // All turns, no owner filter
};
```

#### **Shared Business Rules** (No Changes)
- Turn vs standard booking logic in utils/businessLogic.ts
- Conflict detection and validation utilities
- Priority calculation algorithms
- Error handling with consistent patterns

### **File Naming Conventions**

#### **Role-Based Components**
- **Owner Components**: `Owner` prefix (OwnerSidebar.vue, OwnerCalendar.vue)
- **Admin Components**: `Admin` prefix (AdminSidebar.vue, AdminCalendar.vue)  
- **Shared Components**: No prefix (PropertyCard.vue, TurnAlerts.vue)

#### **Role-Based Composables**
- **Owner Composables**: `useOwner` prefix (useOwnerBookings.ts, useOwnerProperties.ts)
- **Admin Composables**: `useAdmin` prefix (useAdminBookings.ts, useCleanerManagement.ts)
- **Shared Composables**: `use` prefix (useAuth.ts, useValidation.ts)

#### **Existing Conventions** (No Changes)
- **Stores**: camelCase (property.ts, booking.ts, ui.ts)
- **Types**: camelCase (booking.ts, property.ts, ui.ts)  
- **Utils**: camelCase (businessLogic.ts)
- **Pages**: camelCase (index.vue, [id].vue)

### **Role-Based Page Structure**
```
pages/
├── index.vue           # Role-based router (routes to owner/ or admin/)
├── auth/              # Authentication pages
├── owner/             # Property owner pages
│   ├── dashboard.vue  # Uses HomeOwner.vue
│   ├── properties/    # Owner property management
│   ├── bookings/      # Owner booking management  
│   └── calendar.vue   # Owner calendar view
├── admin/             # Business admin pages
│   ├── index.vue      # Uses HomeAdmin.vue
│   ├── schedule/      # Master schedule management
│   ├── cleaners/      # Cleaner management
│   ├── properties/    # All properties management
│   └── reports/       # Business analytics
└── demos/             # Component demos for testing
```

---

## Before Marking Complete:

### **Standard Checks** (No Changes)
- [ ] TypeScript compiles without errors
- [ ] Follows established naming conventions
- [ ] Integrates with existing stores/composables
- [ ] Includes basic error handling
- [ ] Updates any dependent interfaces/types

### **Role-Based Checks** (New)
- [ ] **Data Scoping**: Owner components filter to user's data only
- [ ] **Admin Access**: Admin components access all data without filtering
- [ ] **Component Communication**: Role-specific events work correctly
- [ ] **Security Boundaries**: Document frontend vs backend security
- [ ] **Role Routing**: Proper authentication and role-based routing
- [ ] **Cross-Role Updates**: Changes by one role visible to other role (when appropriate)

---

## Critical Project Concepts:

### **Multi-Tenant Business Logic**
- **Property Owners**: 30-40 Airbnb/VRBO clients, each managing their own properties
- **Cleaning Admin**: Business owner managing all clients, cleaners, and operations
- **Turn bookings**: Urgent, same-day turnovers (scope differs per role)
- **Data Isolation**: Owners see only their data, admin sees all data

### **Role-Based Technical Architecture**
- **Shared Foundation**: Types, stores, business logic, dumb components
- **Role-Specific Layer**: Smart components, composables, pages optimized per role
- **Data Access Patterns**: Filter at composable level, not component level
- **Security Model**: Frontend filtering for UX + future backend RLS for security

### **Turn Priority System** (Cross-Role)
- **Owner View**: "You have 2 urgent turns today" (their properties only)
- **Admin View**: "System has 8 urgent turns today" (all properties)
- **Same Logic**: Priority calculation algorithm shared across roles
- **Different Scope**: Data filtering applied per role

### **Component Reuse Strategy**
```typescript
// ✅ GOOD: Reuse dumb components with different data
<PropertyCard :property="prop" @edit="handleEdit" />  // Same component
// Owner: prop = their property, Admin: prop = any property

// ✅ GOOD: Role-specific smart components
<HomeOwner />   // Optimized for personal property management
<HomeAdmin />   // Optimized for business operations

// ❌ AVOID: Generic components with role props
<Home :userRole="role" :showAdminFeatures="isAdmin" />  // Bad
```

---

## Development Workflow Patterns:

### **Role-Based Development Process**
1. **Identify Role Scope**: Owner-only, admin-only, or shared functionality?
2. **Choose Component Type**: Reuse shared dumb component or create role-specific?
3. **Data Access Pattern**: Use role-specific composable for proper data scoping
4. **Test Both Roles**: Verify owner sees only their data, admin sees all data
5. **Document Security**: Note frontend filtering vs future backend security needs

### **Testing Patterns**
```typescript
// Role-specific data filtering tests
describe('useOwnerBookings', () => {
  it('should return only current owner bookings', () => {
    const { myBookings } = useOwnerBookings();
    expect(myBookings.value.every(b => b.owner_id === currentUser.id)).toBe(true);
  });
});

// Cross-role integration tests
describe('Multi-tenant data updates', () => {
  it('should show owner booking in admin interface', () => {
    // Owner creates booking → Admin should see it
  });
});
```

### **Demo Component Strategy**
- **Shared Components**: Demo with both owner and admin data
- **Role-Specific Components**: Demo with role-appropriate data and features
- **Integration Demos**: Show cross-role data flow and communication

---

## Reference Documentation:

- **Architecture**: @project_summary.md (role-based multi-tenant architecture)
- **Task Structure**: @tasks.md (Phase 1D.5 role-based split tasks)
- **Current State**: @repomix-output.md (existing generic implementation)
- **Component Patterns**: docs/component_orchestration_reference.md
- **Business Logic**: docs/business_logic_reference.md (turn vs standard across roles)
- **Vue Patterns**: docs/vue_typescript_reference.md

---

## Quick Reference - Role Responsibilities:

### **Property Owner Interface (30-40 clients)**
- **Purpose**: Simple property and booking management
- **Data**: Only their properties and bookings
- **Features**: Add properties, create bookings, view personal schedule
- **Turn Alerts**: Only their urgent turns
- **UI**: Clean, focused, mobile-optimized

### **Business Admin Interface (1 user)**  
- **Purpose**: Comprehensive business management
- **Data**: All properties and bookings across all clients
- **Features**: Master calendar, cleaner assignment, business analytics
- **Turn Alerts**: System-wide urgent turns across all clients
- **UI**: Information-dense, desktop-optimized, advanced controls

### **Shared Components & Logic**
- **Types & Interfaces**: All shared (Property, Booking, User)
- **Stores**: Shared Maps with role-based access patterns
- **Business Logic**: Shared algorithms with role-specific scoping
- **Dumb Components**: Reused with different data per role
- **Security**: Frontend filtering for UX, future backend RLS for security