@startuml Business Logic - Property Cleaning Scheduler
!theme plain
title Business Logic - Property Cleaning Scheduler

' Business Logic Utilities
class BusinessLogic {
  ' Priority & Scheduling Functions
  +calculateBookingPriority(booking: Booking): Priority
  +getCleaningWindow(booking: Booking, property: Property): CleaningWindow
  +canScheduleCleaning(booking: Booking, property: Property): SchedulingResult
  
  ' Validation Functions
  +validateBooking(booking: Partial<Booking>, property: Property, existingBookings: Booking[]): ValidationResult
  +validateTurnBooking(booking: Partial<Booking>, property: Property): TurnValidationResult
  
  ' Conflict Detection
  +detectBookingConflicts(booking: Booking, existingBookings: Booking[]): Booking[]
  
  ' Status Management
  +getAvailableStatusTransitions(booking: Booking): BookingStatus[]
  +canTransitionBookingStatus(booking: Booking, newStatus: BookingStatus): boolean
}

' Result Types
class ValidationResult {
  +valid: boolean
  +errors: string[]
  +warnings: string[]
  +conflicts?: Booking[]
}

class TurnValidationResult {
  +valid: boolean
  +errors: string[]
  +warnings: string[]
  +timeDifference: number
  +suggestedTimes?: string[]
}

class SchedulingResult {
  +possible: boolean
  +reason?: string
  +suggestedTimes?: string[]
  +requiredTime: number
  +availableTime: number
}

class CleaningWindow {
  +start: string
  +end: string
  +duration: number
  +bufferTime: number
}

' Composables - Business Logic Abstraction
class UseBookings {
  ' State
  +loading: Ref<boolean>
  +error: Ref<string | null>
  
  ' CRUD Operations
  +fetchAllBookings(): Promise<void>
  +createBooking(bookingData: BookingFormData): Promise<Booking>
  +updateBooking(id: string, updates: Partial<Booking>): Promise<Booking>
  +deleteBooking(id: string): Promise<void>
  
  ' Business Logic Integration
  +validateBookingData(data: BookingFormData): ValidationResult
  +calculatePriority(booking: Booking): Priority
  +detectConflicts(booking: Booking): Booking[]
  +assignCleaner(bookingId: string, cleanerId: string): Promise<Booking>
  +updateStatus(bookingId: string, status: BookingStatus): Promise<Booking>
  
  ' Utility Functions
  +getBookingsByProperty(propertyId: string): Booking[]
  +getBookingsByDateRange(start: string, end: string): Booking[]
  +getTurnBookings(): Booking[]
  +getUrgentBookings(): Booking[]
}

class UseProperties {
  ' State
  +loading: Ref<boolean>
  +error: Ref<string | null>
  
  ' CRUD Operations
  +fetchAllProperties(): Promise<void>
  +createProperty(propertyData: PropertyFormData): Promise<Property>
  +updateProperty(id: string, updates: Partial<Property>): Promise<Property>
  +deleteProperty(id: string): Promise<void>
  
  ' Business Logic
  +calculatePropertyMetrics(propertyId: string): PropertyMetrics
  +getPropertiesByOwner(ownerId: string): Property[]
  +getActiveProperties(): Property[]
  +validatePropertyData(data: PropertyFormData): ValidationResult
}

class UseCalendarState {
  ' Calendar State
  +currentView: Ref<CalendarView>
  +currentDate: Ref<string>
  +selectedPropertyIds: Ref<string[]>
  +dateRange: Ref<{start: string, end: string}>
  
  ' Calendar Navigation
  +setCalendarView(view: CalendarView): void
  +goToDate(date: string): void
  +goToToday(): void
  +next(): void
  +prev(): void
  
  ' Filtering
  +filterBookings(bookings: Booking[]): Booking[]
  +togglePropertyFilter(propertyId: string): void
  +clearPropertyFilters(): void
  +setDateRange(start: string, end: string): void
  
  ' Event Formatting
  +formatBookingForCalendar(booking: Booking, property: Property): CalendarEvent
  +getEventColor(booking: Booking): {background: string, border: string}
  +getEventClassNames(booking: Booking): string[]
}

class UseAuth {
  ' Authentication State
  +user: Ref<User | null>
  +isAuthenticated: Ref<boolean>
  +loading: Ref<boolean>
  +error: Ref<string | null>
  
  ' Authentication Actions
  +login(email: string, password: string): Promise<void>
  +logout(): Promise<void>
  +register(userData: Partial<User>): Promise<void>
  +refreshToken(): Promise<void>
  +checkAuth(): Promise<void>
  
  ' User Management
  +updateProfile(updates: Partial<User>): Promise<void>
  +updateSettings(settings: Partial<UserSettings>): void
  
  ' Authorization
  +hasPermission(permission: string): boolean
  +canAccessResource(resource: string): boolean
}

class UseComponentEventLogger {
  ' Debug State
  +events: Ref<ComponentEvent[]>
  +isEnabled: Ref<boolean>
  
  ' Logging Functions
  +logEvent(source: string, target: string, eventName: string, payload?: any): void
  +logEmit(component: string, eventName: string, payload?: any): void
  +logReceive(component: string, eventName: string, payload?: any): void
  +clearLog(): void
  +toggleLogging(): void
  
  ' Filtering
  +filterByComponent(component: string): ComponentEvent[]
  +filterByEventName(eventName: string): ComponentEvent[]
  +getRecentEvents(count: number): ComponentEvent[]
}

' Supporting Types
class ComponentEvent {
  +id: string
  +timestamp: string
  +source: string
  +target: string
  +eventName: string
  +payload?: any
  +type: 'emit' | 'receive'
}

class PropertyMetrics {
  +utilizationRate: number
  +averageGapBetweenBookings: number
  +turnPercentage: number
  +revenueProjection: number
  +cleaningLoad: 'light' | 'moderate' | 'heavy'
  +totalBookings: number
  +completedBookings: number
  +averageCleaningTime: number
}

' Store Integration
class BookingStore {
  +bookings: Map<string, Booking>
  +createBooking(data: BookingFormData): Promise<Booking>
  +updateBooking(id: string, updates: Partial<Booking>): Promise<Booking>
  +deleteBooking(id: string): Promise<void>
  +getBookingsByProperty(propertyId: string): Booking[]
  +getTurnBookings(): Booking[]
  +getUrgentBookings(): Booking[]
}

class PropertyStore {
  +properties: Map<string, Property>
  +createProperty(data: PropertyFormData): Promise<Property>
  +updateProperty(id: string, updates: Partial<Property>): Promise<Property>
  +deleteProperty(id: string): Promise<void>
  +getActiveProperties(): Property[]
  +calculateMetrics(propertyId: string): PropertyMetrics
}

class UIStore {
  +modals: Map<string, ModalState>
  +notifications: Map<string, Notification>
  +openModal(key: string, mode: string, data?: any): void
  +closeModal(key: string): void
  +addNotification(notification: Omit<Notification, 'id'>): void
}

' Relationships - Composables use Business Logic
UseBookings --> BusinessLogic : "uses validation & calculations"
UseProperties --> BusinessLogic : "uses validation & metrics"
UseCalendarState --> BusinessLogic : "uses priority calculation"

' Relationships - Composables use Stores
UseBookings --> BookingStore : "CRUD operations"
UseProperties --> PropertyStore : "CRUD operations"
UseBookings --> UIStore : "error handling"
UseProperties --> UIStore : "error handling"
UseCalendarState --> UIStore : "filter state"

' Relationships - Business Logic returns Result Types
BusinessLogic --> ValidationResult : "returns"
BusinessLogic --> TurnValidationResult : "returns"
BusinessLogic --> SchedulingResult : "returns"
BusinessLogic --> CleaningWindow : "returns"

' Relationships - Composables return Types
UseProperties --> PropertyMetrics : "calculates"
UseCalendarState --> CalendarEvent : "formats"
UseComponentEventLogger --> ComponentEvent : "logs"

' Business Logic Internal Dependencies
BusinessLogic --> BookingStore : "reads booking data"
BusinessLogic --> PropertyStore : "reads property data"

' Notes
note right of BusinessLogic
  **CORE BUSINESS LOGIC**
  
  **Priority Calculation:**
  - Turn bookings: urgent/high priority
  - Standard bookings: based on time until checkin
  - Considers checkout â†’ checkin time window
  
  **Turn Booking Validation:**
  - Must be same day checkout/checkin
  - Minimum time for cleaning + buffer
  - Warns about tight schedules
  
  **Conflict Detection:**
  - Prevents overlapping bookings
  - Considers cleaning windows
  - Property-specific conflicts only
end note

note right of UseBookings
  **BOOKING COMPOSABLE**
  
  **Responsibilities:**
  - Abstract store operations
  - Integrate business logic validation
  - Handle loading/error states
  - Provide computed booking filters
  
  **Key Features:**
  - Turn vs standard booking handling
  - Real-time conflict detection
  - Priority-based sorting
  - Status workflow management
end note

note right of UseCalendarState
  **CALENDAR STATE MANAGEMENT**
  
  **Responsibilities:**
  - Calendar view state (month/week/day)
  - Date navigation and filtering
  - Property-based filtering
  - Event formatting for FullCalendar
  
  **Integration:**
  - Formats bookings as CalendarEvents
  - Applies business logic for colors
  - Manages filter persistence
end note

note bottom of BusinessLogic
  **BUSINESS RULES ENFORCED**
  
  1. **Turn Bookings** (Same-day checkout/checkin):
     - Always high/urgent priority
     - Minimum 30-minute buffer before checkin
     - Must allow time for cleaning duration
  
  2. **Standard Bookings** (Regular cleanings):
     - Flexible scheduling between checkout/checkin
     - 1-hour buffer before checkin
     - Priority based on time remaining
  
  3. **Conflict Prevention**:
     - No overlapping bookings per property
     - Considers cleaning windows, not just dates
     - Provides alternative time suggestions
end note

@enduml 